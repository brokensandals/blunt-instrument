import * as babel from '@babel/core';
import * as types from '@babel/types';
import { bluntInstrumentPlugin } from '.';

/**
 * Runs blunt-instrument-babel-plugin on the given code and returns the instrumented code.
 * @param {string} code
 * @param {object} pluginOpts - options for the blunt-instrument babel plugin
 * @param {object} babelOpts - options for babel
 * @returns {string}
 */
function transform(code, pluginOpts = {}, babelOpts = {}) {
  return babel.transformSync(code, { plugins: [[bluntInstrumentPlugin, pluginOpts]] , ...babelOpts });
}

/**
 * Runs eval on the given code within global context.
 * @param {string} code - code to eval
 * @returns {*} - result of eval
 */
function codeEval(code) {
  return (0, eval(code));
}

/**
 * Runs blunt-instrument-babel-plugin on the given code, then runs the instrumented code.
 * An object named "output" will be in scope for the code; the code can set properties on
 * it to communicate with the caller. The return value of this method is the "output" object,
 * which also contains an "instrumentation" property which is the instrumentation object
 * generated by blunt-instrument-babel-plugin, and a "code" property which is the input code.
 * 
 * @param {string} code
 * @returns {object}
 */
function biEval(code) {
  const { code: instrumented } = transform(code, { outputs: { assignTo: 'output.instrumentation' }});
  const wrapped = `
    (function() {
      let output = {};
      (function() {${instrumented}})()
      return output;
    })()
  `;
  return { code, ...codeEval(wrapped) };
}

function nodesForCode({ instrumentation: { ast }, code }, target) {
  const matches = [];
  types.traverseFast(ast, (node) => {
    const snippet = code.slice(node.start, node.end);
    if (snippet === target) {
      matches.push(node);
    }
  });
  return matches;
}

function eventsForNode({ instrumentation: { events } }, node) {
  return events.filter((event) => event.nodeId === node.extra.biNodeId);
}

function exprValues(output, target) {
  const nodes = nodesForCode(output, target);
  const events = nodes.flatMap(node => eventsForNode(output, node));
  const exprEvents = events.filter((event) => event.type === 'expr');
  return exprEvents.map(event => event.value);
}

function exprValue(output, target) {
  const vals = exprValues(output, target);
  expect(vals).toHaveLength(1);
  return vals[0];
}

describe('instrumentation object output', () => {
  describe('assignTo', () => {
    it('assigns to a specified variable', () => {
      const { code } = transform('const x = 1', { outputs: { assignTo: 'result' }});
      const wrapped = `
        (function() {
          let result;
          (function() {${code}})()
          return result;
        })()
      `;
      const result = codeEval(wrapped);
      expect(result).toHaveProperty('ast');
      expect(result).toHaveProperty('events');
    });

    it('assigns to an object member', () => {
      const { code } = transform('const x = 1', { outputs: { assignTo: 'this.result' }});
      const wrapped = `
        (function() {
          let obj = {};
          obj.fn = function(){${code}};
          obj.fn();
          return obj.result;
        })()
      `;
      const result = codeEval(wrapped);
      expect(result).toHaveProperty('ast');
      expect(result).toHaveProperty('events');
    });
  });

  describe('exportAs', () => {
    it('exports the specified name', () => {
      const { code } = transform('const x = 1', { outputs: { exportAs: 'result' }});
      const wrapped = `
        (function() {
          let exports = {};
          (function(){${code}})();
          return exports;
        })()
      `;
      const exported = codeEval(wrapped);
      expect(exported.__esModule).toBe(true);
      expect(exported.result).toHaveProperty('ast');
      expect(exported.result).toHaveProperty('events');
    });
  });
});

describe('general examples', () => {
  test('factorial', () => {
    const output = biEval(`
      function fac(n) {
        return n == 1 ? 1 : n * fac(n - 1);
      }

      output.fac5 = fac(5);
    `);
    expect(output.fac5).toEqual(120);
    expect(exprValues(output, 'fac(n - 1)')).toEqual([1, 2, 6, 24]);
    expect(exprValues(output, 'n == 1')).toEqual([false, false, false, false, true]);
  });
});

describe('special case syntax handling', () => {
  describe('method invocations', () => {
    test('this is bound correctly when invoking a method', () => {
      const output = biEval(`
        const obj = { val: 'old' };
        const fn = function() { this.val = 'new'; };
        obj.fn = fn;
        obj.fn();
        output.val = obj.val;
      `);
      expect(output.val).toEqual('new');
      expect(exprValue(output, 'this')).toEqual({ val: 'old'}); // note, this would also include an fn property if the serializer were better
      expect(exprValues(output, 'obj.fn')).toHaveLength(0);
    });

    test('this is bound correctly when invoking the result of a getter, and the getter is only called once', () => {
      // This test exists as a reminder that translating
      // `x.y` to `trace(x.y); x.y()` would not be acceptable.
      const output = biEval(`
        const obj = {
          count: 0,
          get fn() {
            return function() {
              this.count += 1;
            }
          },
        };
        obj.fn();
        output.count = obj.count;
      `);
      expect(output.count).toEqual(1);
      expect(exprValue(output, 'this')).toEqual({ count: 0 });
      expect(exprValues(output, 'obj.fn')).toHaveLength(0);
    });
  });

  test('assign to MemberExpression', () => {
    const output = biEval('const a = [null]; a[0] = 1; output.a0 = a[0];');
    expect(output.a0).toEqual(1);
    expect(exprValue(output, 'a[0] = 1')).toEqual(1);
  });

  describe('UpdateExpression handling', () => {
    test('postfix ++ operator', () => {
      const output = biEval('let x = 1; const a = x++; output.a = a; output.x = x;');
      expect(output.a).toEqual(1);
      expect(output.x).toEqual(2);
      expect(exprValue(output, 'x++')).toEqual(1);
    });
    
    test('prefix ++ operator', () => {
      const output = biEval('let x = 1; const a = ++x; output.a = a; output.x = x;');
      expect(output.a).toEqual(2);
      expect(output.x).toEqual(2);
      expect(exprValue(output, '++x')).toEqual(2);
    });

    test('postfix -- operator', () => {
      const output = biEval('let x = 2; const a = x--; output.a = a; output.x = x;');
      expect(output.a).toEqual(2);
      expect(output.x).toEqual(1);
      expect(exprValue(output, 'x--')).toEqual(2);
    });

    test('prefix -- operator', () => {
      const output = biEval('let x = 2; const a = --x; output.a = a; output.x = x;');
      expect(output.a).toEqual(1);
      expect(output.x).toEqual(1);
      expect(exprValue(output, '--x')).toEqual(1);
    });
    
    test('+= operator', () => {
      const output = biEval('let x = 1; const a = x += 1; output.a = a; output.x = x;');
      expect(output.a).toEqual(2);
      expect(output.x).toEqual(2);
      expect(exprValue(output, 'x += 1')).toEqual(2);
    });
  });
});