import template from '@babel/template';
import * as types from '@babel/types';
import {
  addNodeIdsToAST,
} from 'blunt-instrument-ast-utils';

const buildImportTracer = template(`
  import { defaultTrace as %%tempId%% } from 'blunt-instrument-runtime';
  const %%tracerId%% = %%tempId%%.tracerFor();
`);

const buildRegisterAST = template(`
  %%tracerId%%.ast = JSON.parse(%%astString%%);
`);

const buildFnTrace = template(`{
  %%tracerId%%.record('fn-start', %%nodeId%%, %%args%%, 1);
  try {
    %%body%%
  } catch (e) {
    %%tracerId%%.record('fn-throw', %%nodeId%%, e, -1);
    throw e;
  }
  %%tracerId%%.record('fn-ret', %%nodeId%%, undefined, -1);
}`);

const buildReturnTrace = template(`
  return %%tracerId%%.record('fn-ret', %%nodeId%%, %%retval%%, -1);
`);

function addFnTrace(path, { tracerId }) {
  const { node } = path;

  // Don't trace nodes without a node ID - those are nodes we added
  if (!node.biId) {
    return;
  }

  // If biTracedFn is true, we've already added tracing to this node
  if (node.biTracedFn) {
    return;
  }

  const idNames = new Set(Object.keys(types.getBindingIdentifiers(node.params)));
  // We always want to trace the values of `this` and `arguments`. It's possible
  // to define parameters on a function named `this` and `arguments`, which will
  // supersede the built-in bindings; if the function has done that, `this` and `arguments`
  // will be in the set already.
  idNames.add('this');
  idNames.add('arguments');

  const properties = [];
  idNames.forEach((idName) => {
    const key = types.identifier(idName);
    // When setting a property named `this` in an object expression,
    // the key must be an Identifier node with name=`this`. For setting the
    // value to `this`, either a `ThisExpression` node or an `Identifier` node
    // with name=`this` will work. But if you re-parse the generated code,
    // it's always a `ThisExpression`, so we use that here because blunt-instrument-eval
    // does re-parse the generated code and expect it to have all the same node types
    // as the AST generated by the plugin.
    const val = idName === 'this' ? types.thisExpression() : key;
    properties.push(types.objectProperty(key, val, false, !['this', 'arguments'].includes(idName)));
  });

  let { body } = node;
  if (types.isExpression(body)) {
    body = buildReturnTrace({
      tracerId,
      nodeId: types.numericLiteral(node.biId),
      retval: node.body,
    });
  }

  const trace = buildFnTrace({
    body,
    tracerId,
    nodeId: types.numericLiteral(node.biId),
    args: types.objectExpression(properties),
  });

  node.body = trace;
  node.biTracedFn = true;
}

function addReturnTrace(path, { tracerId }) {
  const { node } = path;

  // Don't trace nodes without a node ID - those are nodes we added
  if (!node.biId) {
    return;
  }

  const trace = buildReturnTrace({
    tracerId,
    nodeId: types.numericLiteral(node.biId),
    retval: node.argument,
  });
  path.replaceWith(trace);
}

const buildExpressionTrace = template(`
  %%tracerId%%.record('expr', %%nodeId%%, %%expression%%)
`);

/**
 * Replaces an expression node with a traced equivalent.
 * For example, rewrites `x + 1` to `tracer.record('expr', 'NODEID', x + 1)`
 * @param {NodePath} path - path containing expression node
 * @param {object} state - metadata returned from addInstrumenterInit
 */
function addExpressionTrace(path, { tracerId }) {
  const { node } = path;

  // Don't trace the retrieval of a method from an object.
  // In other words, this if block detects if we're looking at a node like
  // `x.y` that's part of a node like `x.y()`, and skips tracing if so.
  // Otherwise, we'd rewrite `x.y()` to something like `trace(x.y)()`, which
  // changes the semantics of the program: the former will bind `this` to `x`
  // but the latter will not.
  // I don't know how (if it's possible) to trace the value of `x.y` in this
  // scenario without either breaking the binding of `this`, or evaluating
  // `x.y` twice (which would change the program semantics if `y` is a getter).
  if (types.isMemberExpression(node)
      && types.isCallExpression(path.parentPath.node)
      && path.node === path.parentPath.node.callee) {
    return;
  }

  // Don't trace nodes without a node ID - those are nodes we added
  if (!node.biId) {
    return;
  }

  // If biTracedExpr is true, we've already added tracing for this node
  if (node.biTracedExpr) {
    return;
  }

  // Don't trace identifiers that aren't being evaluated, e.g. the x in `x = 4`
  if (!(path.isReferenced())) {
    return;
  }

  const trace = buildExpressionTrace({
    tracerId,
    nodeId: types.numericLiteral(node.biId),
    expression: node,
  });
  node.biTracedExpr = true;
  path.replaceWith(trace);
}

const basePostfixRewrite = `
  (() => {
    const %%tempId%% = %%lval%%;
    %%lval%% OPERATOR 1;
    return %%tempId%%;
  })()
`;
const postfixRewriteTemplates = {
  '++': template(basePostfixRewrite.replace('OPERATOR', '+=')),
  '--': template(basePostfixRewrite.replace('OPERATOR', '-=')),
};

const instrumentVisitor = {
  UpdateExpression(path) {
    // TODO this is super hacky, and also written when the tracing worked
    // differently, so probably can be simplified
    const op = `${path.node.operator[0]}=`;
    if (path.node.prefix) {
      // Change ++x to x += 1
      const replacement = types.assignmentExpression(
        op, path.node.argument, types.numericLiteral(1),
      );
      replacement.biId = path.node.biId;
      path.replaceWith(replacement);
    } else {
      // Change x++ to (() => { const _postfix = x; x += 1; return _postfix})()
      // TODO: currently, for x++, the original value of x is traced twice:
      // once for the AST node corresponding to 'x' and once for the node corresponding
      // to 'x++'. This seems correct (though tracing the node for 'x' at all may be
      // superfluous) since the original value is the actual value returned by the
      // expression. However, it might be desirable to add a third trace entry of
      // a different type to trace the fact that 'x' is being updated to a new value.
      const lval = path.node.argument;
      const tempId = path.scope.generateUidIdentifier('postfix');
      const replacement = postfixRewriteTemplates[path.node.operator]({ tempId, lval });
      const nodeId = path.node.biId;
      path.replaceWith(replacement);
      // replaceWith appears to drop additional properties, so we must set biId
      // afterward, not before
      // TODO if that's true, why does setting it before work above
      path.node.biId = nodeId; // eslint-disable-line no-param-reassign
    }
  },

  Expression: {
    exit(path) {
      addExpressionTrace(path, this.state);
    },
  },

  Function(path) {
    addFnTrace(path, this.state);
  },

  ReturnStatement(path) {
    addReturnTrace(path, this.state);
  },
};

/**
 * Babel plugin that instruments source code for automatic tracing.
 *
 * See README for usage and options.
 *
 * @param {*} babel
 */
export default function (api, opts) {
  const {
    runtime: {
      mechanism = 'import',
      tracerVar,
    } = {},
    ast: {
      key = 'src',
      selfRegister = true,
    } = {},
  } = opts;

  function addInstrumenterInit(path) {
    const ids = {
      tracerId: tracerVar ? types.identifier(tracerVar)
        : path.scope.generateUidIdentifier('tracer'),
    };

    if (selfRegister) {
      // TODO insert object directly instead of via json
      const astString = types.stringLiteral(JSON.stringify(path.node));
      path.node.body.unshift(buildRegisterAST({
        tracerId: ids.tracerId,
        astString,
      }));
    }

    if (mechanism === 'import') {
      path.node.body.unshift(...buildImportTracer({
        tempId: path.scope.generateUidIdentifier('temp'),
        ...ids,
      }));
    }

    return ids;
  }

  return {
    visitor: {
      Program(path) {
        addNodeIdsToAST(path.node);
        const state = addInstrumenterInit(path);
        path.traverse(instrumentVisitor, { state });
      },
    },
  };
}
